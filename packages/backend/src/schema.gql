# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type APIKey {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  privateKey: String
  description: String!
}

type APIKeyConnection {
  pageInfo: PageInfo!
  edges: [APIKeyEdge!]!
}

type APIKeyEdge {
  node: APIKey!

  """Used in `before` and `after` args"""
  cursor: ID!
}

type Application {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  label: String!
  description: String!
  createdBy: User
  organization: Organization!
  component(id: ID!): Component!
  environments: [Environment!]!
  components(limit: Int!, offset: Int): ComponentConnection!
}

type ApplicationConnection {
  pageInfo: PageInfo!
  edges: [ApplicationEdge!]!
}

type ApplicationEdge {
  node: Application!

  """Used in `before` and `after` args"""
  cursor: ID!
}

type Component {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  label: String!
  deploymentStrategy: DeploymentStrategy!
  image: String!
  monthlyPrice: Int!
  containerGroup(environment: ID!): ContainerGroup
}

type ComponentConnection {
  pageInfo: PageInfo!
  edges: [ComponentEdge!]!
}

type ComponentEdge {
  node: Component!

  """Used in `before` and `after` args"""
  cursor: ID!
}

type ContainerGroup {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  size: ContainerSize!
  containerCount: Float!
  environment: Environment!
  component: Component!
  dnsName: String!
  monthlyPrice: Int!
  secrets(limit: Int!, offset: Int): SecretConnection!
}

enum ContainerSize {
  S1x1
  S2x2
  S4x4
  S8x8
  S16x16
}

input CreateApplicationInput {
  organizationID: ID!
  name: String!
  label: String!
  description: String
}

input CreateComponentInput {
  applicationID: ID!
  name: String!
  label: String!
  image: String!
  deploymentStrategy: DeploymentStrategy!
}

input CreateContainerGroupInput {
  componentID: ID!
  environmentID: ID!
  size: ContainerSize!
  containerCount: Int!
}

input CreateEnvironmentInput {
  organizationID: ID!
  name: String!
  label: String!
}

input CreateRouterInput {
  organizationID: ID!
  label: String!
}

input CreateRouterRuleInput {
  routerID: ID!
  componentID: ID!
  environmentID: ID!
  domain: String!
  pathPrefix: String
  forwardPathPrefix: Boolean
}

input CreateSecretInput {
  containerGroupID: ID!
  key: String!
  value: String!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DeleteApplicationInput {
  applicationID: ID!
}

input DeleteComponentInput {
  componentID: ID!
}

input DeleteRouterInput {
  routerID: ID!
}

input DeleteSecretInput {
  secretID: ID!
}

enum DeploymentStrategy {
  REPLACE
  RECREATE
}

input DisableTOTPInput {
  password: String!
}

input EnableTOTPInput {
  secret: String!
  token: String!
}

type Environment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  label: String!
  organization: Organization!
}

type ExternalEntity {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Mutation {
  createAPIKeyRequest: String!
  grantAPIKey(uuid: String!): Result!
  createAPIKey(description: String!): APIKeyEdge!
  deleteAPIKey(id: ID!): APIKey!
  createApplication(input: CreateApplicationInput!): Application!
  deleteApplication(input: DeleteApplicationInput!): Application!
  updateApplication(input: UpdateApplicationInput!): Application!
  deleteComponent(input: DeleteComponentInput!): Component!
  createComponent(input: CreateComponentInput!): Component!
  createContainerGroup(input: CreateContainerGroupInput!): ContainerGroup!
  createEnvironment(input: CreateEnvironmentInput!): Environment!
  createRouter(input: CreateRouterInput!): Router!
  deleteRouter(input: DeleteRouterInput!): Router!
  createRouterRule(input: CreateRouterRuleInput!): RouterRule!
  createSecret(input: CreateSecretInput!): Secret!
  updateSecret(input: UpdateSecretInput!): Secret!
  deleteSecret(input: DeleteSecretInput!): Secret!
  exchangeTOTP(token: String!): Result!
  enableTOTP(input: EnableTOTPInput!): User!
  disableTOTP(input: DisableTOTPInput!): User!
  signUp(password: String!, email: String!, name: String!, username: String!): Result!
  signIn(password: String!, email: String!): SignInResult!
  gitHubSignIn(code: String!): SignInResult!
  updateAccount(email: String, name: String, username: String): User!
  forgotPassword(email: String!): Result!
  resetPassword(password: String!, uuid: String!): Result!
  signOut: Result!
}

type Network {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type Notification {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  body: String!
}

type Organization {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  isPersonal: Boolean!
  username: String!
  name: String!
  maxComputeUnits: Float!
  environments: [Environment!]!
  routers: [Router!]!
  applications(limit: Int!, offset: Int): ApplicationConnection!
  application(name: String!): Application!
  memberCount: Int!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: ID
  endCursor: ID
}

type Query {
  getAPIKeyFromRequest(uuid: String!): String
  application(id: ID!): Application!
  component(id: ID!): Component!
  estimateMonthlyPrice(count: Int!, size: ContainerSize!): Int!
  notifications: [Notification!]!
  organization(username: String!): Organization!
  router(id: ID!): Router!
  viewer: User!
}

"""Provides a boolean to determine if the action was successful or not."""
type Result {
  ok: Boolean!
}

type Router {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  label: String!
  organization: Organization!
  rules(limit: Int!, offset: Int): RouterRuleConnection!
}

type RouterRule {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  domain: String!
  pathPrefix: String
  forwardPathPrefix: Boolean
  component: Component!
  environment: Environment!
}

type RouterRuleConnection {
  pageInfo: PageInfo!
  edges: [RouterRuleEdge!]!
}

type RouterRuleEdge {
  node: RouterRule!

  """Used in `before` and `after` args"""
  cursor: ID!
}

type Secret {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  key: String!
  value: String!
}

type SecretConnection {
  pageInfo: PageInfo!
  edges: [SecretEdge!]!
}

type SecretEdge {
  node: Secret!

  """Used in `before` and `after` args"""
  cursor: ID!
}

"""
A special type of result used just for SignIns. Provides a boolean for if the
user requires a TOTP exchange before being fully logged in.
"""
type SignInResult {
  ok: Boolean!
  requiresTOTP: Boolean!
}

input UpdateApplicationInput {
  applicationID: ID!
  name: String
  label: String
  description: String
}

input UpdateComponentInput {
  componentID: ID!
  name: String
  label: String
  image: String
  deploymentStrategy: DeploymentStrategy
}

input UpdateSecretInput {
  secretID: ID!
  key: String!
  value: String!
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  username: String!
  email: String!
  personalOrganization: Organization!
  onboardTOTP: String!
  hasTOTP: Boolean!
  apiKeys(limit: Int!, offset: Int): APIKeyConnection!
  organizations: [Organization!]!
}
